<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>netty 踩坑记 | lelouchcr&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/app.css">
  <!-- <link rel='stylesheet' href='http://fonts.useso.com/css?family=Source+Code+Pro'> -->
</head>

<body>
  <nav class="app-nav">
  
    
      <a href="/.">home</a>
    
  
    
      <a href="/archives">archive</a>
    
  
    
      <a href="/atom.xml">rss</a>
    
  
</nav>

  <main class="post">
  <article>
  <h1 class="article-title">
    <a href="/2016/08/27/netty-hole/">netty 踩坑记</a>
  </h1>

  <section class="article-meta">
    <p class="article-date">August 27 2016</p>
  </section>

  <section class="article-entry">
    <p>以下netty 版本为 4.1.x</p>
<p>最近项目的收官阶段，开始压测，然后发现效果没有想象的好，再用 <code>gcutil</code> 看内存，发现竟然有严重的内存泄露！</p>
<p>仔细研究了一下，发现是因为我的使用方式不对。</p>
<p>最初开发的时候，没有研究过netty的底层实现，但是看过 <a href="https://blog.twitter.com/2013/netty-4-at-twitter-reduced-gc-overhead" target="_blank" rel="external">twitter发的对netty4 的 ByteBufPool 的测评</a>，<br>于是就在写代码的时候就想着尽量池化。</p>
<p>错误的方式 差不多是下面这样的代码.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// decode 部分, 重用 bootstrap 用 PooledByteBufAllocator 分配的Bytebuf, 交给handler</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> available = in.readableBytes();</span><br><span class="line">  <span class="keyword">if</span> (available &gt; <span class="number">4</span>) &#123; <span class="comment">// read frame handle half package</span></span><br><span class="line">    in.markReaderIndex();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] i32buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">    in.readBytes(i32buf);</span><br><span class="line">    <span class="comment">// 这个total 不包括frame 的4 个字节</span></span><br><span class="line">    <span class="keyword">int</span> totalSize = decodeFrameSize(i32buf);</span><br><span class="line">    <span class="keyword">if</span> (available &lt; totalSize + <span class="number">4</span>) &#123; <span class="comment">// read frame handle half package</span></span><br><span class="line">      in.resetReaderIndex();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Constants.MessageType messageType = isXXProtocol(in);</span><br><span class="line">      Message message = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (messageType) &#123;</span><br><span class="line">        <span class="keyword">case</span> XX1:</span><br><span class="line">          message = <span class="keyword">new</span> Message();</span><br><span class="line">          message.setBody(ink.readRetainedSlice(totalSize));</span><br><span class="line">          out.add(message);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> xx2:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handler 部分，接受 decode 出来的 Object</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, <span class="keyword">final</span> Message request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  threadPoolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Message response = messageHandler.handle(request); <span class="comment">// 这里的 request 就是decode的msg，里面包含了IO线程分配的Bytebuf </span></span><br><span class="line">      <span class="keyword">if</span> (ctx.channel().isActive()) &#123;</span><br><span class="line">        ctx.writeAndFlush(response, ctx.voidPromise());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">assert</span> request.getBody().refCnt() == <span class="number">1</span>;</span><br><span class="line">      ReferenceCountUtil.release(request.getBody()); <span class="comment">// 释放上面的bytebuf</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看起来代码没有问题，但是事实上由于netty4 的cache特性，造成了内存泄露。</p>
<p>netty4 有个 <a href="http://netty.io/wiki/using-as-a-generic-library.html#thread-local-object-pool" target="_blank" rel="external">Thread-local object pool</a> </p>
<p>netty 在很多地方都用它来做cache</p>
<p>用来做 cache。做什么cache呢，<br>用来做ByteBufPool 的cache，也就是说每当有请求server 的时候，先从Threadlocal 找之前cache 过的Bytebuf，</p>
<p>当使用 worker 的optional 是 PooledByteBufAllocator 时 netty 处理请求时 的内存分配流程是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">                          +-----------------+  +-----------------+</span><br><span class="line">                          |IO thread for write |IO thread for read    1. Inbound 字节流存入ByteBuf中。</span><br><span class="line">   3. 将encode好的Bytebuf  |                 |  |                 |    Bytebuf 优先从Threadlocal获取，</span><br><span class="line">   写出到socket，回收Bytebuf|            ^    |  |   +             |    ThreadLocal没有，则再从pool中获取。</span><br><span class="line">   到 ThreadLocal         |            |    |  |   |             |</span><br><span class="line">                          |            |    |  |   |             |</span><br><span class="line">                          |            |    |  |   |             |</span><br><span class="line">                          |            |    |  |   |             |</span><br><span class="line">                          |            |    |  |   |             |</span><br><span class="line">                          |            |    |  |   |             |</span><br><span class="line">                          |            +    |  |   v             |</span><br><span class="line">                          |                 |  |                 |</span><br><span class="line">                          |       +----------------------+       |</span><br><span class="line">+-------------------+     |       |         |  |         |       |</span><br><span class="line">|  heap or          | +---------&gt; |   thread local cache |       |</span><br><span class="line">|  direct           |     |       |         |  |         |       |</span><br><span class="line">|                   |     +-------+---------+--+---+-----+-------+     2.一般来说在business handler 中将解码的数据</span><br><span class="line">|  ByteBuf pool     |     |                        |             |     放到自己的业务线程池，防止由于阻塞降低IO thread</span><br><span class="line">|                   | &lt;----------------------------+             |     的吞吐</span><br><span class="line">|                   |     |           +------------------+       |    +------------------------+</span><br><span class="line">+-------------------+     |           |                  |       |    |  business thread       |</span><br><span class="line">                          |           |decoder           |       |    | +--------------------+ |</span><br><span class="line">                          |           |                  |       |    | |                    | |</span><br><span class="line">                          |           |                  |       |    | +--------------------+ |</span><br><span class="line">                          |           |business handler+------------&gt; |                        |</span><br><span class="line">                          |           |                  |       |    | +--------------------+ |</span><br><span class="line">                          |           |                  |       |    | |                    | |</span><br><span class="line">                          |           |encoder           |       |    | +--------------------+ |</span><br><span class="line">                          |           |                  |       |    |                        |</span><br><span class="line">                          |           |                  |       |    |      .......           |</span><br><span class="line">                          |           +------------------+       |    |                        |</span><br><span class="line">                          |  pipeline is also in IO thread       |    |                        |</span><br><span class="line">                          +--------------------------------------+    +------------------------+</span><br></pre></td></tr></table></figure>
<p>所以，如果我将 1 中 获得的Bytebuf 在2 中的业务线程释放，于是 <code>ByteBuf.release</code> 的流程将会把Bytebuf 存入到当前的Threadlocal。(这个Threadlocal 无法释放) </p>
<p>于是内存泄漏了。</p>
<p>那么问题来了，既然netty 已经支持了 BytebufPool 为何还要用 Threadlocal 做Cache呢？</p>
<p>这里有个官方的 <a href="https://github.com/netty/netty/pull/2284" target="_blank" rel="external">benchmark</a> 解释了主要是因为 directByteBuf 的获取比较慢。。也就是说，这个优化主要是针对 DirectBytebufPool的</p>
<p>总结来说，如果要使用 PooledByteBuf，一定要注意 allocate 和 release 是同一个线程</p>
<p>但是这里要注意，我们的IOThread 可以配置 <code>&gt;1</code> 的, 因为有时我们希望我们的 encoder 和 decoder 能过利用多个核, 这里要注意，在你使用多个线程的时候，你的 ThreadLocal 也变成了多个，<br>这些Threadlocal 都会进入老年代，并且永远不会被释放，需要压测看看，配置合理的内存大小，避免由于内存过小，造成频繁full gc</p>
<p>对了，这个cache的特性还能够关闭 具体代码在 <code>io.netty.util.Recycler</code> static 代码块, 可以通过 <code>System.setProperty(&quot;io.netty.recycler.maxCapacity&quot;, &quot;0&quot;);</code> 或以<br>java param 的方式 <code>-Dio.netty.recycler.maxCapacity=0</code> 关闭</p>
<p>还有PooledByteBuf 的cahce是这样子的cache，他cache的是自己的是自己的对象，所以，这个cache 也继承了整个netty 的类似jmelloc 的内存分页方式, 并且他的大小是和Pooled Bytebuf 大小是一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// PooledArena</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> PooledByteBuf&lt;ByteBuffer&gt; <span class="title">newByteBuf</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (HAS_UNSAFE) &#123;</span><br><span class="line">        <span class="keyword">return</span> PooledUnsafeDirectByteBuf.newInstance(maxCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PooledDirectByteBuf.newInstance(maxCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PooledUnsafeDirectByteBuf</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> PooledUnsafeDirectByteBuf <span class="title">newInstance</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    PooledUnsafeDirectByteBuf buf = RECYCLER.get();</span><br><span class="line">    buf.setRefCnt(<span class="number">1</span>);</span><br><span class="line">    buf.maxCapacity(maxCapacity);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// PooledHeapByteBuf </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> PooledHeapByteBuf <span class="title">newInstance</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    PooledHeapByteBuf buf = RECYCLER.get();</span><br><span class="line">    buf.setRefCnt(<span class="number">1</span>);</span><br><span class="line">    buf.maxCapacity(maxCapacity);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以如果你用的是 PooledHeapByteBuf 如果有 2个 IOThread 那么 cache 的总数是3。</p>
<p>所以，如果关心内存的使用情况， 了解netty内存池的分配非常重要，关于这个<a href="http://blog.csdn.net/pentiumchen/article/details/45372625" target="_blank" rel="external">发现这篇文章写的很好</a></p>
<p>然后根据自己的业务情况，以及可能的线程数，预估 最大的内存耗费. 或者直接压测， 23333</p>
<p>还有，如果 业务线程也使用了PooledBytebuf 的话， 同理.</p>
<p>于是，知道了这个原因后, 为了验证下，于是在 decoder 里面用 UnpooledHeapBytebuf 做一次内存拷贝，然后试试看是否能修复。</p>
<p>代码如下 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (messageType) &#123;</span><br><span class="line">  <span class="keyword">case</span> xx1:</span><br><span class="line">    message = <span class="keyword">new</span> Message();</span><br><span class="line">    message.setBody(Unpooled.copiedBuffer(in));</span><br><span class="line">    out.add(message);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> xx2:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>压测后发现，老年代依然会逐步增加，最终导致fullgc</p>
<p>objectDump 后发现大量的Recycler 和 WeakHashMap 对象。明明Unpooled 申请Bytebuf 的时候并没有和ThreadLocal相关，为何还会有Recycle呢？</p>
<p>后来发现是在 business Thread writeAndFlush 的时候, 会区分线程, 如果是在 <code>IO 线程</code> writeAndFlush 则会直接调用，不然则是提交一个runnable</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, <span class="keyword">boolean</span> flush, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext next = findContextOutbound();</span><br><span class="line">    <span class="keyword">final</span> Object m = pipeline.touch(msg, next);</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">            next.invokeWriteAndFlush(m, promise);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.invokeWrite(m, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        AbstractWriteTask task;</span><br><span class="line">        <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">            task = WriteAndFlushTask.newInstance(next, m, promise);</span><br><span class="line">        &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">            task = WriteTask.newInstance(next, m, promise);</span><br><span class="line">        &#125;</span><br><span class="line">        safeExecute(executor, task, promise, m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提交任务后, 依旧是从 ThreadLocal 中获取 <code>WriteAndFlushTask</code> ，这里的 <code>WriteAndFlushTask</code> 被重用了。</p>
<p>这里可以肯定，这里的 <code>WriteAndFlushTask</code> 一定是会在IO线程释放, 如果和上面的 PooledByteBuf 比较，岂不是内存泄漏了？</p>
<p>我们继续看下去，看释放的时候做了些什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">safeExecute</span><span class="params">(EventExecutor executor, Runnable runnable, ChannelPromise promise, Object msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            executor.execute(runnable);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                promise.setFailure(cause);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ReferenceCountUtil.release(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个 executor 其实就是 当初 调用 businessThread 的 <code>ChannelHandlerContext</code> 这里插播一句， <code>ChannelHandlerContext</code> 和 <code>eventLoop</code> 是一对多的关系， 前者为一，后者为多</p>
<p>也就是说，这个runnable被 提交到 eventLoop 去了，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NioEventLoop / SingleThreadEventExecutor#execute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"task"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> inEventLoop = inEventLoop();</span><br><span class="line">    <span class="keyword">if</span> (inEventLoop) &#123;</span><br><span class="line">        addTask(task);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        startThread();</span><br><span class="line">        addTask(task);</span><br><span class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp; removeTask(task)) &#123;</span><br><span class="line">            reject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</span><br><span class="line">        wakeup(inEventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ps，这里的逻辑和我以前看tornado 的eventLoop 的 大逻辑差不多，但是 netty 多了不少细节(细节以后有时间再展开，这里就说说大体流程)</p>
<p>通过上面 addTask 将 上面的 <code>WriteAndFlushTask</code> 提交到一个taskQueue</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NioEventLoop / SingleThreadEventExecutor#execute</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"task"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!offerTask(task)) &#123;</span><br><span class="line">            reject(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">offerTask</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isShutdown()) &#123;</span><br><span class="line">            reject();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> taskQueue.offer(task);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后就是loop 环节, </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// NioEventLoop#run()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅仅贴部分代码，省去了分配时间比例的代码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// tornado 的代码就类似这样，还有 tornado 是先处理挤压的task 再处理IO</span></span><br><span class="line">      processSelectedKeys();</span><br><span class="line">      runAllTasks();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      logger.warn(<span class="string">"Unexpected exception in the selector loop."</span>, t);</span><br><span class="line">      <span class="comment">// Prevent possible consecutive immediate failures that lead to</span></span><br><span class="line">      <span class="comment">// excessive CPU consumption.</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="comment">// Ignore.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再loop里面 执行 <code>WriteAndFlushTask</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractChannelHandlerContext.AbstractWriteTask#run()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ChannelOutboundBuffer buffer = ctx.channel().unsafe().outboundBuffer();</span><br><span class="line">        <span class="comment">// Check for null as it may be set to null if the channel is closed already</span></span><br><span class="line">        <span class="keyword">if</span> (ESTIMATE_TASK_SIZE_ON_SUBMIT &amp;&amp; buffer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            buffer.decrementPendingOutboundBytes(size);</span><br><span class="line">        &#125;</span><br><span class="line">        write(ctx, msg, promise);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Set to null so the GC can collect them directly</span></span><br><span class="line">        ctx = <span class="keyword">null</span>;</span><br><span class="line">        msg = <span class="keyword">null</span>;</span><br><span class="line">        promise = <span class="keyword">null</span>;</span><br><span class="line">        handle.recycle(<span class="keyword">this</span>); <span class="comment">// 还记得前面在BusinessThread 里面 `RECYCLER.get();` 吗， 这里就是回收</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过看到这里，我知道了大体流程是怎样的了，但是具体的跨线程是如何做到cache的还是没看到(有点跑偏),所以下面着重看Recycler 的get 和 recycle 的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recyler  @BusinessThread</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FastThreadLocal&lt;Stack&lt;T&gt;&gt; threadLocal = <span class="keyword">new</span> FastThreadLocal&lt;Stack&lt;T&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Stack&lt;T&gt; <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里的 Thread.currentThread() 就是我们的 Business Thread</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Stack&lt;T&gt;(Recycler.<span class="keyword">this</span>, Thread.currentThread(), maxCapacity, maxSharedCapacityFactor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Recycler#get()  @BusinessThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 关闭cache 的时候，每次都 new 对象，</span></span><br><span class="line">    <span class="keyword">if</span> (maxCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> newObject((Handle&lt;T&gt;) NOOP_HANDLE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// threadLocal 里面放一个 Stack， </span></span><br><span class="line">    Stack&lt;T&gt; stack = threadLocal.get(); <span class="comment">// 这里的threadLocal 就是上面的 FastThreadLocal</span></span><br><span class="line">    DefaultHandle&lt;T&gt; handle = stack.pop(); <span class="comment">// 通过pop 获得cache的 DefaultHandle</span></span><br><span class="line">    <span class="keyword">if</span> (handle == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handle = stack.newHandle();</span><br><span class="line">        handle.value = newObject(handle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) handle.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------- different context ----------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Recycler.DefaultHandle  @EventLoopThread (WorkerThread/IOThread)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> FastThreadLocal&lt;Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt;&gt; DELAYED_RECYCLED =</span><br><span class="line">        <span class="keyword">new</span> FastThreadLocal&lt;Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt;&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt; initialValue() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WeakHashMap&lt;Stack&lt;?&gt;, WeakOrderQueue&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Recycler.DefaultHandle#recycle()   @EventLoopThread (WorkerThread/IOThread)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (object != value) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"object does not belong to handle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Thread thread = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 这边我们走不到，因为这里是在IOThread里，而stack的thread是business Thread</span></span><br><span class="line">    <span class="keyword">if</span> (thread == stack.thread) &#123;</span><br><span class="line">        stack.push(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// we don't want to have a ref to the queue as the value in our weak map</span></span><br><span class="line">    <span class="comment">// so we null it out; to ensure there are no races with restoring it later</span></span><br><span class="line">    <span class="comment">// we impose a memory ordering here (no-op on x86)</span></span><br><span class="line">    Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt; delayedRecycled = DELAYED_RECYCLED.get();</span><br><span class="line">    WeakOrderQueue queue = delayedRecycled.get(stack);</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        queue = WeakOrderQueue.allocate(stack, thread);</span><br><span class="line">        <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// drop object</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        delayedRecycled.put(stack, queue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过这一步将 DefaultHandle 放回queue</span></span><br><span class="line">    queue.add(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，这里的 <code>queue.add</code> 和 <code>stack.pop</code> 明明是2个对象，怎么就串联起来了呢</p>
<p>代码比较长，我直接画图表示下</p>
<p><img src="/post_images/netty.png" alt="wiki/netty/netty.png"></p>
<p>也就是说 一个Thread 最多cache <code>256</code> 个 <code>WriteAndFlushTask</code> 对象, 总数又 <code>IO Thread</code> 数量决定, 默认最多应该是 IOThreadCount * 256 个对象</p>
<p>超过这个数字的话都直接 new 一次性对象了。</p>
<p>所以这个是不会造成内存泄漏的，所以回到之前的问题，为什么用Unpool还会造成 老年代持续上升。</p>
<p>后来我将 selector 线程 和 IO 线程都改成 1个 然后，然后 print 出每次请求的id(每次请求id 自增)，发现 id 并不同步，降低频率后可以同步，也就是说，</p>
<p>server 没有将buf 写出去，由于是在 businessThread 里写 response 是提交到 IOLoop 里面 的queue 的，然后 IOLoop 里面 是 给 读的IO 事件和别的 所有异步事件 各 50% 的时间 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">  <span class="comment">// 省略 xxx</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio;<span class="comment">// 默认是 50</span></span><br><span class="line">    <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123; </span><br><span class="line">        processSelectedKeys();</span><br><span class="line">        runAllTasks();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先处理IO时间，</span></span><br><span class="line">        processSelectedKeys();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">        runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isShuttingDown()) &#123;</span><br><span class="line">        closeAll();</span><br><span class="line">        <span class="keyword">if</span> (confirmShutdown()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 省略 xxx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个Task 不仅仅是 WriteAndFlushTask 还有 CloseTask， registerTask, 等等返回xxxFuture 的基本都是靠他实现的。</p>
<p>虽然在我们的压测情况下，除了 WriteAndFlushTask, 别的可以忽略不计，还有就是 如果写的太快，造成task 积压过多。</p>
<p>所以，在一个异步的系统里面 设置 <a href="http://normanmaurer.me/presentations/2014-facebook-eng-netty/slides.html#11.0" target="_blank" rel="external">waterMark</a> 非常重要</p>
<p>事后，在看netty issue的时候，也有人遇到了同样的问题  <a href="https://github.com/netty/netty/issues/5563" target="_blank" rel="external">https://github.com/netty/netty/issues/5563</a></p>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p><a href="http://blog.csdn.net/pentiumchen/article/details/45372625" target="_blank" rel="external">http://blog.csdn.net/pentiumchen/article/details/45372625</a></p>
<p><a href="http://www.cnblogs.com/rainy-shurun/p/5213086.html" target="_blank" rel="external">http://www.cnblogs.com/rainy-shurun/p/5213086.html</a></p>
<p><a href="http://redis.io/commands/eval#available-libraries" target="_blank" rel="external">http://redis.io/commands/eval#available-libraries</a></p>
<p><a href="http://normanmaurer.me/presentations/2014-facebook-eng-netty/slides.html" target="_blank" rel="external">http://normanmaurer.me/presentations/2014-facebook-eng-netty/slides.html</a></p>

  </section>
</article>

  <div class="sharing grid">
  <section class="profile grid-item grid">
    <img class="avatar" src="https://gravatar.css.network/avatar/f6adb1529491a56dbe31c57d519585f5?s=400&r=g" alt="avatar" />
    <div class="grid-item">
      <p class="title"> lelouchcr's blog </p>
      <p class="subtitle">  </p>
    <div>
  </section>

  <section class="share-btns">
    <!-- <p> share it if you like it~ </p> -->
    <a
  class="twitter-share-button"
  data-size="large"
  data-via="DrakeLeung"
  href="https://twitter.com/intent/tweet?text=以下netty 版本为 4.1.x</p"
>
  Tweet
</a>

<script>
  window.twttr = (function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0],
    t = window.twttr || {};
  if (d.getElementById(id)) return t;
  js = d.createElement(s);
  js.id = id;
  js.src = "https://platform.twitter.com/widgets.js";
  js.async = true;
  fjs.parentNode.insertBefore(js, fjs);

  t._e = [];
  t.ready = function(f) {
    t._e.push(f);
  };

  return t;
}(document, "script", "twitter-wjs"));
</script>

  </section>
</div>


  
    
<section class="article-comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

<script>
  var disqus_shortname = 'caorong';
  
  var disqus_url = 'http://caorong.github.io/2016/08/27/netty-hole/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


  
  

<script>
    setTimeout(function() {
            var hjs = document.createElement('script');
            hjs.setAttribute('src', 'http://acgart.download/rand?ratio=0.625&range=0.2&source=pixiv&encode=jsc&func=lgallery');
            document.body.appendChild(hjs);
        }, 0);

    function lgallery(option) {
            console.log(option);
            var bgimg = document.createElement('img');
            bgimg.setAttribute('src', option.p_ori);
            bgimg.setAttribute('id', 'bkImg');
            bgimg.setAttribute('onmousedown', 'return false');
            document.body.appendChild(bgimg);
        }

</script>

</main>

</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Understand Tornado | lelouchcr&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link rel="shortcut icon" href="/favicon.ico">
  <meta name="referrer" content="same-origin">
  <meta name="referrer" content="no-referrer" />
  <link rel="stylesheet" href="/css/app.css">
  <!-- <link rel='stylesheet' href='http://fonts.useso.com/css?family=Source+Code+Pro'> -->
</head>

<body>
  <nav class="app-nav">
  
    
      <a href="/.">home</a>
    
  
    
      <a href="/archives">archive</a>
    
  
    
      <a href="/atom.xml">rss</a>
    
  
</nav>

  <main class="post">
  <article>
  <h1 class="article-title">
    <a href="/2015/08/16/understand-tornado/">Understand Tornado</a>
  </h1>

  <section class="article-meta">
    <p class="article-date">August 16 2015</p>
  </section>

  <section class="article-entry">
    <p>让我们先来写一个hello world</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @tornado.gen.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.write(<span class="string">"Hello, world"</span>)</span><br><span class="line"></span><br><span class="line">application = tornado.web.Application([</span><br><span class="line">    (<span class="string">r"/"</span>, MainHandler),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    application.listen(<span class="number">8888</span>)</span><br><span class="line">    tornado.ioloop.IOLoop.current().start()</span><br></pre></td></tr></table></figure></p>
<p>上面这个程序表示在 <code>8888</code> 端口启动一个webserver, 然后访问后返回 <code>Hello world</code></p>
<p>要了解他的机理，先要理解以下几点</p>
<h2>epoll</h2>
<p>为了了解这个，我们得先了解什么是 epoll, 以及 epoll 的编程例子。</p>
<p>这个可以参考参考<a href="http://zoomq.qiniudn.com/ZQScrapBook/ZqFLOSS/data/20100927213110/" target="_blank" rel="external">这里</a>的Example 3</p>
<h2>Generator</h2>
<p>python的迭代器 类似ruby 的fiber， 都可以作迭代，异步传值</p>
<h3>迭代</h3>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Data</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self._data = list(args)</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">for</span> x <span class="keyword">in</span> self._data:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">yield</span> x</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = Data(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> d:</span><br><span class="line"><span class="meta">... </span>    print(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(i <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x10fd7ed38</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[i <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure></p>
<h3>传值</h3>
<p>举个例子</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        re = <span class="keyword">yield</span> i</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"v_%s = %s"</span> % (i, re)</span><br><span class="line"></span><br><span class="line">g = foo(<span class="number">2</span>)      <span class="comment"># 1</span></span><br><span class="line"><span class="keyword">print</span> g.next()  <span class="comment"># 2</span></span><br><span class="line"><span class="keyword">print</span> g.next()  <span class="comment"># 3</span></span><br><span class="line"><span class="keyword">print</span> g.next()  <span class="comment"># 4</span></span><br></pre></td></tr></table></figure></p>
<p>上面的代码输出的是：</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">v_0 = None</span><br><span class="line">1</span><br><span class="line">v_1 = None</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/Users/ryan/Workspace/myself/Tornadjango/app/tmp.py&quot;, line 10, in &lt;module&gt;</span><br><span class="line">    print g.next()</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure></p>
<p>1 得到一个generator，且在1的时候，foo函数不会有任何的执行。在解释器分析代码的时候，发现foo里面有yield，就已经把它当成一个generator了。</p>
<p>2 得到generator的第一个值 0</p>
<p>3 得到generator的第二个值 1</p>
<p>4 由于generator已经完毕，所以，抛出StopIteration异常</p>
<p>然而yield的返回都是None</p>
<ul>
<li>注意 generator.next() 等于  next(generator) py2 两种写法都支持，py3 只支持后者</li>
</ul>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"coroutine start..."</span></span><br><span class="line">    result = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        s = <span class="keyword">yield</span> result</span><br><span class="line">        result = <span class="string">'result: &#123;&#125;'</span>.format(s)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = coroutine() <span class="comment"># 函数返回协程对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.send(<span class="keyword">None</span>) <span class="comment"># 使用 send(None) 或 next() 启动协程  send(None) == next(c)</span></span><br><span class="line">coroutine start...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.send(<span class="string">"first"</span>) <span class="comment"># 向协程发送消息,使其恢复执⾏</span></span><br><span class="line"><span class="string">'result: first'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.send(<span class="string">"second"</span>)</span><br><span class="line"><span class="string">'result: second'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.close() <span class="comment"># 关闭协程,使其退出。或⽤c.throw() 使其引发异常</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.send(<span class="string">"never recv"</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure></p>
<ol>
<li>generator.next() 等价于 generator.send(None)</li>
<li>对于一个generator，一定要先调用一个next，或者send(None)。才能再调用send(value)</li>
<li>调用send(value)的时候，会把value的值赋给里面的接收者，且是上一次next的中断位置</li>
</ol>
<p>关于generator的其他教程</p>
<p>http://blog.bitfoc.us/?p=502</p>
<p>http://dongweiming.github.io/Expert-Python/#22</p>
<p><a href="http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python" target="_blank" rel="external">stackoverflow 的例子</a></p>
<h2>decorator pattern</h2>
<p>先讲讲 <code>@tornado.gen.coroutine</code> 是什么，干什么用的，这种写法又是什么意思？</p>
<p>其实这是一种装饰模式，java 里面也很常见，比如 thrift client 的配置</p>
<p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"monitorMsgClient"</span> <span class="attr">class</span>=<span class="string">"com.ximalaya.thrift.client.ThriftClient"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"clientFactory"</span> <span class="attr">ref</span>=<span class="string">"monitorCollecterFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"thriftMonitorCollecterClient"</span> <span class="attr">class</span>=<span class="string">"com.ximalaya.live.president.inf.thrift.client.impl.MonitorMsgThriftClientServiceImpl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"monitorMsgClient"</span> <span class="attr">ref</span>=<span class="string">"monitorMsgClient"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><code>com.ximalaya.thrift.client.ThriftClient</code> 代码</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(ClassUtils.getCurrentClassLoader(), <span class="keyword">new</span> Class[]&#123;iface&#125;, <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            ThriftConnection&lt;?&gt; connection = clientFactory.getConnection();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                T client = (T) connection.getClient();</span><br><span class="line">                <span class="keyword">return</span> method.invoke(client, args);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.getCause();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以在这里 monitorMsgClient 其实已经不是纯粹的 Iface 对象了，而是一个被修饰过的对象，当然这里这么用的目的是少写代码。</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> Iface monitorMsgClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remindFailMsgOfRadio</span><span class="params">(String errorCode, String errorMsg, <span class="keyword">int</span> radioId, <span class="keyword">int</span> audioSegmentId)</span></span><br><span class="line">        <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> monitorMsgClient.remindFailMsgOfRadio(errorCode, errorMsg, radioId, audioSegmentId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TException(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么我们回过头再来看 python 的 decorator</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">common</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">_deco</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">print</span> <span class="string">'args:'</span>, args</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> _deco</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@common</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(p)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> p</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test</span><br><span class="line">&lt;function _deco at <span class="number">0x10d996a28</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test(<span class="number">1</span>)</span><br><span class="line">args: (<span class="number">1</span>,)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>这里的 <code>func(*args, **kwargs)</code> 相当于 java 的 <code>method.invoke(client, args);</code></p>
<p>同样， 当别人调用 test 函数的时候， 这个test函数已经不是原来的test函数了。</p>
<p>不过tornado 里面用个更高级的 decorator <code>@functools.wraps</code>, 至于他的作用，看下面的代码就知道了</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">without_wraps</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> __wrapper</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">with_wraps</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> __wrapper</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">@without_wraps</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func_a</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""Here is my_func_a doc string text."""</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@with_wraps</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func_b</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""Here is my_func_b doc string text."""</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># Below are the results without using @wraps decorator</span></span><br><span class="line"><span class="keyword">print</span> my_func_a.__doc__</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">None</span></span><br><span class="line"><span class="keyword">print</span> my_func_a.__name__</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>__wrapper</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Below are the results with using @wraps decorator</span></span><br><span class="line"><span class="keyword">print</span> my_func_b.__doc__</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Here <span class="keyword">is</span> my_func_b doc string text.</span><br><span class="line"><span class="keyword">print</span> my_func_b.__name__</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_func_b</span><br></pre></td></tr></table></figure></p>
<p>其实就是保证了一些元数据不丢</p>
<p>这里了解了 @decorator 那么跟着看源码 tornado 如何利用 @tornado.gen.coroutine 做到异步</p>
<h2>猜测tornado的整体流程</h2>
<p>通过上面的基础知识，大致可以联想一下tornado的流程</p>
<h3>最最简易版的 handler</h3>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler1</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.write(<span class="string">"123"</span>)</span><br></pre></td></tr></table></figure></p>
<ol>
<li>cliet发起请求</li>
<li>server 的 epoll 收到个event，请求连接</li>
<li>server register client connection</li>
<li>server 的 epoll 收到 register 执行完成，将 request_header 读入内存</li>
<li>server 根据 handler + method 调用handler 的相应方法， method 的 默认实现皆为 raise 405</li>
<li>method 将output 的string 异步写入 connection</li>
</ol>
<ul>
<li>其中 4 是不等待3是否完成，3执行完毕后由 epoll 通知4</li>
<li>6 是异步写入connection 同上，回调关闭连接</li>
</ul>
<p>结束</p>
<p>流程是如此，tornado 在实现的时候，利用了 decorator 和 yield 在实现异步，使用的方式如下</p>
<ol>
<li>
<p>被 decorate 的代码 比如 @gen.coroutine 遇到 yield， 那么我们执行func 得到的必然是 一个generator</p>
</li>
<li>
<p>next(generator) 将带 yield 的func 执行到 yield 处，返回yield 后面的代码块</p>
</li>
<li>
<p>yield 后的代码块执行完成后通过 <code>通知</code> 触发 Runner，然后通过 generator 的send 将 yield 右边的结果写入yield左边，实现异步。</p>
</li>
</ol>
<p>注， 上面的 <code>通知</code> 在ioloop 里面 有callback 和 epoll.poll 两种实现方式, 后有详细说明。</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        result = func(*args, **kwargs)  <span class="comment"># 1 result 是一个 generator </span></span><br><span class="line">        <span class="keyword">if</span> isinstance(result, types.GeneratorType):</span><br><span class="line">            yielded = next(result) <span class="comment"># yielded 为</span></span><br><span class="line">            <span class="comment">#...</span></span><br><span class="line">            Runner(result, future, yielded)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runner</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, gen, result_future, first_yielded)</span>:</span></span><br><span class="line">        self.gen = gen</span><br><span class="line">        self.result_future = result_future</span><br><span class="line">        self.future = _null_future</span><br><span class="line">        <span class="keyword">if</span> self.handle_yield(first_yielded):</span><br><span class="line">            self.run()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">        yielded = self.gen.send(value)</span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 举个简单例子加强理解</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"coroutine start..."</span></span><br><span class="line">    result = <span class="keyword">lambda</span> x: print(<span class="string">'lala %s'</span> % x)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        s = <span class="keyword">yield</span> result</span><br><span class="line">        result = <span class="string">'result: &#123;&#125;'</span>.format(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; c = coroutine()</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; c</span></span><br><span class="line"><span class="comment"># &lt;generator object coroutine at 0x10fb9eab0&gt;</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; xx = next(c)</span></span><br><span class="line"><span class="comment"># conr start..</span></span><br><span class="line"><span class="comment"># &gt;&gt;&gt; xx</span></span><br><span class="line"><span class="comment"># &lt;function coroutine.&lt;locals&gt;.&lt;lambda&gt; at 0x10fe6d268&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>拿到函数后 我自然就可以在<code>恰当的时机</code>执行他(比如收到io 完成的通知的时候)</p>
<h3>tips</h3>
<p>在这最简单的情况下我们应该会收到2个 epoll 的 event</p>
<p>不过通过调试发现现实会与想象的不同</p>
<ol>
<li>
<p>在本地请求 比如 <code>curl localhost:8080/t</code> 会显示收不到 4 的event，暂时没找到原因，但如果 先ssh 到别的机器在请求就能看到效果...</p>
</li>
<li>
<p>在满足 1 的情况下，本地用pycharm debug 还是会看不到 4 的event，但是却是是有event的，解决方法，这个event的观察不能 debug下执行，(原因暂未想通) 直接在tornado 源码上增加</p>
</li>
</ol>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意 linux 是 epoll ， 而且是二进制的 看不到代码 ＝ ＝</span></span><br><span class="line"><span class="comment"># .../tornado/platform/kqueue.py  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在register 里面打印堆栈</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(self, fd, events)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> inspect, traceback</span><br><span class="line">    print(<span class="string">'[kqueue register] called - %s %s'</span> % (__file__, inspect.currentframe().f_back.f_lineno))</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> traceback.format_stack():</span><br><span class="line">        print(line.strip())</span><br><span class="line">    print()</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p>请在下面地方增加注释，便于发现以上步骤</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ioloop.start()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">with</span> self._callback_lock:</span><br><span class="line">        print(<span class="string">'_callbacks'</span>, self._callbacks)</span><br><span class="line">        callbacks = self._callbacks</span><br><span class="line">        self._callbacks = []</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        event_pairs = self._impl.poll(poll_timeout)</span><br><span class="line">        print(<span class="string">'event_pairs'</span>, event_pairs)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></p>
<p>以上注释便于发现，服务启动后，如果没有请求则会不断打印以下数据，而且debug 某个请求的时候，会停止print 充分说明 ioloop 是单线程的，以及阻塞某个请求会影响整个服务</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">event_pairs dict_items([])</span><br><span class="line">_callbacks []</span><br><span class="line">event_pairs dict_items([])</span><br><span class="line">_callbacks []</span><br><span class="line">event_pairs dict_items([])</span><br><span class="line">_callbacks []</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h2>@tornado.gen.coroutine</h2>
<p>简化版的代码</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine</span><span class="params">(func, replace_callback=True)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> _make_coroutine_wrapper(func, replace_callback=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_make_coroutine_wrapper</span><span class="params">(func, replace_callback)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        future = TracebackFuture()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            result = func(*args, **kwargs)  <span class="comment"># 如果func 内有 yield 的话，result 是&lt;generator xx&gt;</span></span><br><span class="line">        <span class="keyword">except</span> (Return, StopIteration) <span class="keyword">as</span> e:</span><br><span class="line">            result = getattr(e, <span class="string">'value'</span>, <span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            future.set_exc_info(sys.exc_info())</span><br><span class="line">            <span class="keyword">return</span> future</span><br><span class="line">        <span class="keyword">if</span> isinstance(result, types.GeneratorType):</span><br><span class="line">            yielded = next(result)  <span class="comment">#py3 的用法 == result.next()   启动generator， 将func执行到yield 这里，然后返回后面的代码块</span></span><br><span class="line">            Runner(result, future, yielded)</span><br><span class="line">            <span class="keyword">return</span> future</span><br><span class="line">            </span><br><span class="line">        future.set_result(result)</span><br><span class="line">        <span class="keyword">return</span> future</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure></p>
<p>也就是说当我们的被注解的函数</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@tornado.gen.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.write(<span class="string">"Hello, world"</span>)</span><br></pre></td></tr></table></figure></p>
<ol>
<li>如果内部不存在 yield 则执行函数后直接返回一个future</li>
</ol>
<p>被注解的函数内存在 <code>yield</code> 的话，那么一开始得到的result是 一个 generator 并没有被执行，而在下面调用next 进行初始化，然后交给下面的 Runner</p>
<h2>ioloop</h2>
<p>然后我们再来看 tornado 的 ioloop 模块</p>
<p>根据上面的 epoll example 我们可以猜到，tornado 的大致流程，一旦有请求过来，先触发一个 epoll 事件。然后做一个 register。 然后</p>
<p>看了代码后，发现她还有callback的</p>
<p>也就是说，ioloop 有2种触发器，一个是 socket 的，一个是 带 timeout 的 callback， socket 是通过epoll 触发代码如下</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ioloop.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    event_pairs = self._impl.poll(poll_timeout)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e: </span><br><span class="line">    <span class="comment"># 收到 socket 连接提醒， </span></span><br><span class="line">    <span class="comment"># 收到 socket 数据读取完毕提醒</span></span><br></pre></td></tr></table></figure></p>
<p>一个是 callback, 比如 <code>@run_on_executor</code> 他是在 decoretor 里面 将被 装饰的函数 submit 到threadpool 执行</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># ioloop.py</span><br><span class="line"></span><br><span class="line">for callback in callbacks:</span><br><span class="line">    self._run_callback(callback)</span><br><span class="line"></span><br><span class="line">def _run_callback(self, callback):</span><br><span class="line">    &quot;&quot;&quot;Runs a callback with error handling.</span><br><span class="line"></span><br><span class="line">    For use in subclasses.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    try:</span><br><span class="line">        ret = callback()</span><br><span class="line">        if ret is not None and is_future(ret):</span><br><span class="line">            # 将依据</span><br><span class="line">            self.add_future(ret, lambda f: f.result())</span><br><span class="line">    except Exception:</span><br><span class="line">        self.handle_callback_exception(callback)</span><br></pre></td></tr></table></figure></p>
<h2>epoll.poll 类型代码解析</h2>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    event_pairs = self._impl.poll(poll_timeout)</span><br><span class="line">    print(<span class="string">'event_pairs'</span>, event_pairs)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">self._events.update(event_pairs)</span><br><span class="line"><span class="keyword">while</span> self._events:</span><br><span class="line">    fd, events = self._events.popitem()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        fd_obj, handler_func = self._handlers[fd]</span><br><span class="line">        handler_func(fd_obj, events)</span><br><span class="line">    <span class="keyword">except</span> (OSError, IOError) <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">if</span> errno_from_exception(e) == errno.EPIPE:</span><br><span class="line">            <span class="comment"># Happens when the client closes the connection</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.handle_callback_exception(self._handlers.get(fd))</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        self.handle_callback_exception(self._handlers.get(fd))</span><br><span class="line">fd_obj = handler_func = <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<p>ioloop 通过 收到的 event 调用相应的 handler</p>
<h2>callback 类型代码解析 (run_on_executor_decorator)</h2>
<p>将被注解的 function 提交到 threadpool 执行</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># concurrent.py l.365</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_on_executor_decorator</span><span class="params">(fn)</span>:</span></span><br><span class="line">    executor = kwargs.get(<span class="string">"executor"</span>, <span class="string">"executor"</span>)</span><br><span class="line">    io_loop = kwargs.get(<span class="string">"io_loop"</span>, <span class="string">"io_loop"</span>)</span><br><span class="line"><span class="meta">    @functools.wraps(fn)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        callback = kwargs.pop(<span class="string">"callback"</span>, <span class="keyword">None</span>)</span><br><span class="line">        future = getattr(self, executor).submit(fn, self, *args, **kwargs)</span><br><span class="line">        <span class="keyword">if</span> callback:</span><br><span class="line">            getattr(self, io_loop).add_future(</span><br><span class="line">                future, <span class="keyword">lambda</span> future: callback(future.result()))</span><br><span class="line">        <span class="keyword">return</span> future</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure></p>
<p>提交上去后返回 future</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gen.py _make_coroutine_wrapper</span></span><br><span class="line"></span><br><span class="line">yielded = next(result)</span><br><span class="line">Runner(result, future, yielded)</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">这里的Runner 对象干了很多事情，因为我们将任务交给thread 处理，那么我们怎么知道 task 已经完成</span><br><span class="line"></span><br><span class="line">tornado 在初始化 Runner 对象的时候在最后一步先判断 future 是否依旧完成， 如果没有完成则在 ioloop 里面加一个future （add_future）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="comment"># gen.py </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runner</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, gen, result_future, first_yielded)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.handle_yield(first_yielded):</span><br><span class="line">            self.run()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_yield</span><span class="params">(self, yielded)</span>:</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.future.done() <span class="keyword">or</span> self.future <span class="keyword">is</span> moment:</span><br><span class="line">            self.io_loop.add_future(</span><br><span class="line">                self.future, <span class="keyword">lambda</span> f: self.run())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ioloop</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_future</span><span class="params">(self, future, callback)</span>:</span></span><br><span class="line">    <span class="string">"""Schedules a callback on the ``IOLoop`` when the given</span><br><span class="line">    `.Future` is finished.</span><br><span class="line"></span><br><span class="line">    The callback is invoked with one argument, the</span><br><span class="line">    `.Future`.</span><br><span class="line">    """</span></span><br><span class="line">    <span class="keyword">assert</span> is_future(future)</span><br><span class="line">    callback = stack_context.wrap(callback)</span><br><span class="line">    future.add_done_callback(</span><br><span class="line">        <span class="keyword">lambda</span> future: self.add_callback(callback, future))</span><br></pre></td></tr></table></figure></p>
<p>ioloop.add_future 里则给 future 加一个 add_done_callback, 也就是thread task 完成后执行</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> future: self.add_callback(callback, future)</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">而这个self 时ioloop， 也就是ioloop 里面 轮训的callback 多了一条， 相当于 ioloop 收到了信息。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">简化版</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            event_pairs = self._impl.poll(poll_timeout)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="comment"># Depending on python version and IOLoop implementation,</span></span><br><span class="line">            <span class="comment"># different exception types may be thrown and there are</span></span><br><span class="line">            <span class="comment"># two ways EINTR might be signaled:</span></span><br><span class="line">            <span class="comment"># * e.errno == errno.EINTR</span></span><br><span class="line">            <span class="comment"># * e.args is like (errno.EINTR, 'Interrupted system call')</span></span><br><span class="line">            <span class="keyword">if</span> errno_from_exception(e) == errno.EINTR:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Pop one fd at a time from the set of pending fds and run</span></span><br><span class="line">        <span class="comment"># its handler. Since that handler may perform actions on</span></span><br><span class="line">        <span class="comment"># other file descriptors, there may be reentrant calls to</span></span><br><span class="line">        <span class="comment"># this IOLoop that update self._events</span></span><br><span class="line">        self._events.update(event_pairs)</span><br><span class="line">        <span class="keyword">while</span> self._events:</span><br><span class="line">            fd, events = self._events.popitem()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                fd_obj, handler_func = self._handlers[fd]</span><br><span class="line">                handler_func(fd_obj, events)</span><br><span class="line">            <span class="keyword">except</span> (OSError, IOError) <span class="keyword">as</span> e:</span><br><span class="line">                <span class="keyword">if</span> errno_from_exception(e) == errno.EPIPE:</span><br><span class="line">                    <span class="comment"># Happens when the client closes the connection</span></span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.handle_callback_exception(self._handlers.get(fd))</span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                self.handle_callback_exception(self._handlers.get(fd))</span><br><span class="line">        fd_obj = handler_func = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_handler</span><span class="params">(self, fd, handler, events)</span>:</span></span><br><span class="line">    fd, obj = self.split_fd(fd)</span><br><span class="line">    self._handlers[fd] = (obj, stack_context.wrap(handler))</span><br><span class="line">    self._impl.register(fd, events | self.ERROR)</span><br></pre></td></tr></table></figure></p>
<p>可以看到，ioloop 是一个死循环，他不停的取出epoll 中的事件，然后根据fd，拿出fd 对应的handler, 然后交给handler处理。</p>
<p>结合上面的epoll 例子，我们可以想象，所有的对 IO(socket) 有操作的都会注册到机器环境的 epoll 中，然后循环地获取完成io的事件。</p>
<p>也就是说，利用系统的回调来省去自己对io 的等待。</p>
<h2>练手</h2>
<p>我估计，光看上面的写的也只有我自己能看懂，于是我写一个简化版的带 ioloop， coroutine 以及 run_on_executor 的实现，帮助理解关键部分，理解了后再看上面，并跟着看源码代码应该就能理解了。</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> types</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FakeIOloop</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    线程实现的伪ioloop, 真正tornado的是没有这个Thread的</span><br><span class="line">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._callback = []</span><br><span class="line">        thread = Thread(target=self.start, args=())</span><br><span class="line">        thread.start()</span><br><span class="line">        <span class="comment"># thread.join()</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_callback</span><span class="params">(self, cb)</span>:</span></span><br><span class="line">        self._callback.append(cb)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># print('cb', self._callback)</span></span><br><span class="line">            <span class="keyword">if</span> self._callback:</span><br><span class="line">                x = self._callback.pop(</span><br><span class="line">                    <span class="number">0</span>)  <span class="comment"># &lt;function coroutine.&lt;locals&gt;.wrapper.&lt;locals&gt;.&lt;lambda&gt;.&lt;locals&gt;.&lt;lambda&gt; at 0x1051689d8&gt;</span></span><br><span class="line">                <span class="comment"># 该x 就是 coroutine 中的  send_result 函数</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    x()</span><br><span class="line">                <span class="keyword">except</span> (StopIteration) <span class="keyword">as</span> e:</span><br><span class="line">                    <span class="comment"># print(e)</span></span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ioloop = FakeIOloop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_on_executor</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_on_executor_deco</span><span class="params">(fn)</span>:</span></span><br><span class="line">        executor = kwargs.get(<span class="string">"executor"</span>, <span class="string">"executor"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">        @wraps(fn)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">            future = getattr(self, executor).submit(fn, self, *args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> future</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> run_on_executor_deco</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">'1.'</span>, result)</span><br><span class="line">        <span class="keyword">if</span> isinstance(result, types.GeneratorType):</span><br><span class="line">            <span class="comment"># run the self.test</span></span><br><span class="line">            yielded = next(result)</span><br><span class="line">            print(<span class="string">'3.'</span>, yielded)</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">send_result</span><span class="params">(future)</span>:</span></span><br><span class="line">                print(<span class="string">'inner send result called !!!!'</span>)</span><br><span class="line">                result.send(future.result())</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 在线程内添加一个完成后的回调，该回调将在ioloop内添加一个callback，并在该callback内执行上面的函数</span></span><br><span class="line">            yielded.add_done_callback(<span class="keyword">lambda</span> x: ioloop.add_callback(<span class="keyword">lambda</span>: send_result(x)))</span><br><span class="line">            <span class="keyword">return</span> yielded</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCls</span><span class="params">(object)</span>:</span></span><br><span class="line">    executor = ThreadPoolExecutor(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getdata_without_sleep</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"i am not blocked"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getdata_with_sleep</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'2.'</span>, self.test_block)</span><br><span class="line">        result = <span class="keyword">yield</span> self.test_block(<span class="string">'333'</span>)</span><br><span class="line">        print(<span class="string">'4...'</span>, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="meta">    @run_on_executor(executor='executor')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_block</span><span class="params">(self, a)</span>:</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"finish %s "</span> % a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    tcls = TestCls()</span><br><span class="line">    <span class="comment"># 执行内含sleep的func</span></span><br><span class="line">    tcls.getdata_with_sleep()</span><br><span class="line">    tcls.getdata_without_sleep()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. &lt;generator object getdata_with_sleep at 0x10f713900&gt;</span></span><br><span class="line"><span class="comment"># 2. &lt;bound method TestCls.test_block of &lt;__main__.TestCls object at 0x10f711f28&gt;&gt;</span></span><br><span class="line"><span class="comment"># 3. &lt;Future at 0x10f711f60 state=running&gt;</span></span><br><span class="line"><span class="comment"># 1. i am not blocked</span></span><br><span class="line"><span class="comment"># inner send result called !!!!</span></span><br><span class="line"><span class="comment"># 4... finish 333</span></span><br></pre></td></tr></table></figure></p>
<p>可见 <code>getdata_without_sleep</code> 函数并没有被上个函数的sleep阻塞。
<code>getdata_with_sleep</code> 函数内的 <code>test_block</code> 的结果由ioloop 内send</p>
<h2>_handler 启动时的注册</h2>
<p>main.py application.listen(xx)</p>
<p>web.py listen</p>
<p>tcpserver.py listen</p>
<p>socket.bind  <code>AF_INET</code> 和 <code>AF_INET6</code> 的2个 socket  在指定端口建2个socket</p>
<p>顺便学习下socket</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">af, socktype, proto, canonname, sockaddr = res</span><br><span class="line"></span><br><span class="line"><span class="comment">## AF_INET is the address family that is used for the socket you're creating (in this case an Internet Protocol address). The Linux kernel, for example, supports 29 other address families such as UNIX sockets and IPX, and also communications with IRDA and Bluetooth (AF_IRDA and AF_BLUETOOTH, but it is doubtful you'll use these at such a low level).</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># For the most part sticking with AF_INET for socket programming over a network is the safest option.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## Stream Sockets: Delivery in a networked environment is guaranteed. If you send through the stream socket three items "A, B, C", they will arrive in the same order - "A, B, C". These sockets use TCP (Transmission Control Protocol) for data transmission. If delivery is impossible, the sender receives an error indicator. Data records do not have any boundaries.</span></span><br><span class="line"><span class="comment"># http://www.tutorialspoint.com/unix_sockets/what_is_socket.htm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 第三个是protocol</span></span><br><span class="line"><span class="comment">#IPPROTO_IP = 0   system default</span></span><br><span class="line"><span class="comment">#IPPROTO_TCP = 6  tornado，（） </span></span><br><span class="line"><span class="comment"># http://stackoverflow.com/questions/7346695/strange-linux-socket-protocols-behaviour</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Giving 0 as protocol to socket just means that you want to use the default protocol for the family/socktype pair. In this case that is TCP, and thus you get the same result as with IPPROTO_TCP.  orz</span></span><br><span class="line"></span><br><span class="line">sock.listen(backlog)  <span class="comment"># &#123;int&#125; 128</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The maximum length of the queue of pending connections</span></span><br></pre></td></tr></table></figure></p>
<p>通过 netutil.py 注册到ioloop</p>
<p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> sock <span class="keyword">in</span> sockets:</span><br><span class="line">    self._sockets[sock.fileno()] = sock</span><br><span class="line">    add_accept_handler(sock, self._handle_connection,</span><br><span class="line">                       io_loop=self.io_loop)</span><br></pre></td></tr></table></figure></p>
<p>在这里 add-accept_handler 的时候就建立了与客户端的 socket <code>self._impl.register(fd, events | self.ERROR)</code></p>
<h3>那么与 web 层 的requestHandler 如何映射?</h3>
<p>listener的端口，收到 epoll 的 event， 然后建立连接, 读数据, 正则匹配handler， 反射根据get,post等 调用相应 handler 然后如果handler 里面有io 则同上，如果是基于socket的 则由 epoll 通知，用thread 的则由 callback（带timeout的）通知。</p>
<p>这里仅仅说 client 发起的纯 request</p>
<p>web 层的
(httpserver.handle_stream)</p>
<p>读 header 是在 iostream.py 的 <code>_run_read_callback</code></p>
<p>读完header后，根据输入的正则，匹配handler 然后根据 header 数据调方法</p>
<h2>总结</h2>
<p>tornado 内还有很多东西，由于时间原因，以后再写吧。</p>
<h2>reference</h2>
<p>http://zoomq.qiniudn.com/ZQScrapBook/ZqFLOSS/data/20100927213110/</p>
<p>http://www.cnblogs.com/yiwenshengmei/archive/2011/06/08/understanding_tornado.html</p>
<p>https://artemrudenko.wordpress.com/2013/04/15/python-why-you-need-to-use-wraps-with-decorators/</p>
<p>http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python</p>
<p>http://www.pengyi.info/tag/Tornado/?page=1</p>
<p>http://blog.xiaogaozi.org/2012/09/21/understanding-tornado-dot-gen/</p>
<p>http://dongweiming.github.io/Expert-Python/</p>
<p>http://www.slideshare.net/emptysquare/nyc-python-meetup-coroutines-2013-0416</p>

  </section>
</article>

  <div class="sharing grid">
  <section class="profile grid-item grid">
    <img class="avatar" src="https://gravatar.cat.net/avatar/f6adb1529491a56dbe31c57d519585f5?s=400&r=g" alt="avatar" />
    <div class="grid-item">
      <p class="title"> lelouchcr's blog </p>
      <p class="subtitle">  </p>
    <div>
  </section>

  <section class="share-btns">
    <!-- <p> share it if you like it~ </p> -->
    <a
  class="twitter-share-button"
  data-size="large"
  data-via="DrakeLeung"
  href="https://twitter.com/intent/tweet?text=让我们先来写一个hello world<"
>
  Tweet
</a>

<script>
  window.twttr = (function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0],
    t = window.twttr || {};
  if (d.getElementById(id)) return t;
  js = d.createElement(s);
  js.id = id;
  js.src = "https://platform.twitter.com/widgets.js";
  js.async = true;
  fjs.parentNode.insertBefore(js, fjs);

  t._e = [];
  t.ready = function(f) {
    t._e.push(f);
  };

  return t;
}(document, "script", "twitter-wjs"));
</script>

  </section>
</div>


  
    
<section class="article-comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

<script>
  var disqus_shortname = 'caorong';
  
  var disqus_url = 'http://caorong.github.io/2015/08/16/understand-tornado/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


  
  

<script>
    setTimeout(function() {
            var hjs = document.createElement('script');
            hjs.setAttribute('src', 'https://acgart.download/rand?ratio=0.625&range=0.2&source=pixiv&encode=jsc&func=lgallery');
            document.body.appendChild(hjs);
        }, 0);

    function lgallery(option) {
            console.log(option);
            var bgimg = document.createElement('img');
            bgimg.setAttribute('src', option.p_ori);
            bgimg.setAttribute('id', 'bkImg');
            bgimg.setAttribute('onmousedown', 'return false');
            bgimg.setAttribute('referrerpolicy', 'no-referrer');
            document.body.appendChild(bgimg);
        }

</script>

</main>

</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>little schemer in Clojure chapter 9 Lambda the Ultimate | lelouchcr&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/app.css">
  <!-- <link rel='stylesheet' href='http://fonts.useso.com/css?family=Source+Code+Pro'> -->
</head>

<body>
  <nav class="app-nav">
  
    
      <a href="/.">home</a>
    
  
    
      <a href="/archives">archive</a>
    
  
    
      <a href="/atom.xml">rss</a>
    
  
</nav>

  <main class="post">
  <article>
  <h1 class="article-title">
    <a href="/2015/03/14/the-little-schemer-in-clojure-chapter-9/">little schemer in Clojure chapter 9 Lambda the Ultimate</a>
  </h1>

  <section class="article-meta">
    <p class="article-date">March 14 2015</p>
  </section>

  <section class="article-entry">
    <p>翻译自 <a href="http://juliangamble.com/blog/2012/09/15/the-little-schemer-in-clojure-chapter-9-lambda-the-ultimate-deriving-the-y-combinator/" target="_blank" rel="external">juliangamble - The Little Schemer in Clojure – Chapter 9 Lambda the Ultimate</a> </p>
<p>这是 <a href="http://www.ccs.neu.edu/home/matthias/BTLS/" target="_blank" rel="external">The Little Schemer</a> to Clojure 的第九章</p>
<p>注，后文讲用 TLS 代替 The Little Schemer</p>
<p>这一章是本书最重要的地方，前几章，基本一天能看一章，这一章看了一个礼拜。你也许听过 Paul Graham 的 天使投资公司，<a href="http://ycombinator.com/" target="_blank" rel="external">Ycombinator</a> － 这一章我们不仅仅解释 YCombinator 并在 Clojure中实现它。</p>
<p>首先，神马是 <code>YCombinator</code> 理论？<code>The YCombinator is a way to do recursion in a language that doesn’t support recursion. Instead recursion is defined as a set of rewrite rules.</code> 也就是说他是一章方法，可以在不支持递归的语言里面使用递归。用一系列重写规则代替递归。</p>
<p>不是吧，就我所知不支持递归的语言要追溯到60年代了。现在再说这个还有神马意义马？其实，仅仅为了上面的理由是没有意义的，他的意义在于构造lazy function 以及 数据结构 － Clojure 里面非常实用的东西 － 并且在别的lisp语言里比较稀有。</p>
<p>让我们开始吧。</p>
<p><code>rember-f</code> 它包含一个list，一个atom， 一个比较函数，如下解释</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;demonstrating passing functions around</span></span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> rember-f</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [test? a l]</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">      (<span class="name">null?</span> l) '()</span><br><span class="line">      <span class="literal">true</span> (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">             (<span class="name">test?</span> (<span class="name"><span class="builtin-name">first</span></span> l) a) (<span class="name"><span class="builtin-name">rest</span></span> l)</span><br><span class="line">             <span class="literal">true</span> (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name"><span class="builtin-name">first</span></span> l) (<span class="name">rember-f</span> test? a (<span class="name"><span class="builtin-name">rest</span></span> l)))))))</span><br><span class="line"> </span><br><span class="line">(<span class="name">println</span> (<span class="name">rember-f</span> = '(<span class="name"><span class="builtin-name">pop</span></span> corn) '(<span class="name">lemonade</span> (<span class="name"><span class="builtin-name">pop</span></span> corn) and (<span class="name">cake</span>))))</span><br><span class="line"><span class="comment">;//=&gt;(lemonade and (cake))</span></span><br></pre></td></tr></table></figure>
<p>我们把 （＝） 作为比较函数，用来去掉list 里面于a相同的atom</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 简化版</span></span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> rember-f</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [test? a l]</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">      (<span class="name">null?</span> l) '()</span><br><span class="line">      (<span class="name">test?</span> (<span class="name"><span class="builtin-name">first</span></span> l) a) (<span class="name"><span class="builtin-name">rest</span></span> l)</span><br><span class="line">      <span class="literal">true</span> (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name"><span class="builtin-name">first</span></span> l) (<span class="name">rember-f</span> test? a (<span class="name"><span class="builtin-name">rest</span></span> l))))))</span><br><span class="line"> </span><br><span class="line">(<span class="name">println</span> (<span class="name">rember-f</span> = '(<span class="name"><span class="builtin-name">pop</span></span> corn) '(<span class="name">lemonade</span> (<span class="name"><span class="builtin-name">pop</span></span> corn) and (<span class="name">cake</span>))))</span><br><span class="line"><span class="comment">;//=&gt;(lemonade and (cake))</span></span><br></pre></td></tr></table></figure>
<p>现在我们要讲讲 curried（柯里化 scala也有强调）。他的名字是根据数学家 <a href="http://en.wikipedia.org/wiki/Haskell_Curry" target="_blank" rel="external">Haskell Curry</a>而来的。 curring 一个函数的意思是，将原本需要2个入参的函数改造成1个入参，并仍然返回一个结果函数，（只有一个入参的函数）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(def eq?-c</span><br><span class="line">  (fn [a]</span><br><span class="line">    (fn [x]</span><br><span class="line">      (= x a))))</span><br><span class="line"> </span><br><span class="line">(println (eq?-c 'lemonade))</span><br><span class="line">=&gt; (println (eq?-c 'lemonade))</span><br><span class="line">#&lt;Chapter9LambdaTheUltimate$eq_QMARK__c$fn__974 Chapter9LambdaTheUltimate$eq_QMARK__c$fn__974@2a2a2ae9&gt;</span><br><span class="line">(println ((eq?-c 'lemonade) 'coke))</span><br><span class="line">;//=&gt; false</span><br><span class="line">(println ((eq?-c 'lemonade) 'lemonade))</span><br><span class="line">;//=&gt; true</span><br><span class="line"> </span><br><span class="line">(def eq?-salad (eq?-c 'salad))</span><br><span class="line"> </span><br><span class="line">(println (eq?-salad 'tuna))</span><br><span class="line">;//=&gt;false</span><br><span class="line">(println (eq?-salad 'salad))</span><br><span class="line">;//=&gt;true</span><br></pre></td></tr></table></figure>
<p>curry 版本的 rember-f </p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> rember-f</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [test?]</span><br><span class="line">    (<span class="name"><span class="builtin-name">fn</span></span> [a l]</span><br><span class="line">      (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">        (<span class="name">null?</span> l) '()</span><br><span class="line">        (<span class="name">test?</span> (<span class="name"><span class="builtin-name">first</span></span> l) a) (<span class="name"><span class="builtin-name">rest</span></span> l)</span><br><span class="line">        <span class="literal">true</span> (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name"><span class="builtin-name">first</span></span> l) ((<span class="name">rember-f</span> test?) a (<span class="name"><span class="builtin-name">rest</span></span> l)))))))</span><br><span class="line"> </span><br><span class="line">(<span class="name">println</span> ((<span class="name">rember-f</span> =) 'tuna '(<span class="name">tuna</span> salad is good)))</span><br><span class="line"><span class="comment">;//=&gt;(salad is good)</span></span><br><span class="line"> </span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> rember-eq? (<span class="name">rember-f</span> =))</span><br><span class="line">(<span class="name">println</span> (<span class="name">rember-eq?</span> 'tuna '(<span class="name">tuna</span> salad is good)))</span><br><span class="line"><span class="comment">;//=&gt;(salad is good)</span></span><br></pre></td></tr></table></figure>
<p>curry化 insert-L</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> insertL-f</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [test?]</span><br><span class="line">    (<span class="name"><span class="builtin-name">fn</span></span> [new old l]</span><br><span class="line">      (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">        (<span class="name">null?</span> l) '()</span><br><span class="line">        (<span class="name">test?</span> (<span class="name"><span class="builtin-name">first</span></span> l) old) (<span class="name"><span class="builtin-name">cons</span></span> new (<span class="name"><span class="builtin-name">cons</span></span> old (<span class="name"><span class="builtin-name">rest</span></span> l)))</span><br><span class="line">        <span class="literal">true</span> (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name"><span class="builtin-name">first</span></span> l) ((<span class="name">insertL-f</span> test?) new old (<span class="name"><span class="builtin-name">rest</span></span> l)))))))</span><br><span class="line"> </span><br><span class="line">(<span class="name">println</span> ((<span class="name">insertL-f</span> =) 'creamy 'latte '(<span class="name">a</span> hot cup of latte)))</span><br></pre></td></tr></table></figure>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> insertR-f</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [test?]</span><br><span class="line">    (<span class="name"><span class="builtin-name">fn</span></span> [new old l]</span><br><span class="line">      (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">        (<span class="name">null?</span> l) '()</span><br><span class="line">        (<span class="name">test?</span> (<span class="name"><span class="builtin-name">first</span></span> l) old) (<span class="name"><span class="builtin-name">cons</span></span> old (<span class="name"><span class="builtin-name">cons</span></span> new (<span class="name"><span class="builtin-name">rest</span></span> l)))</span><br><span class="line">        <span class="literal">true</span> (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name"><span class="builtin-name">first</span></span> l) ((<span class="name">insertR-f</span> test?) new old (<span class="name"><span class="builtin-name">rest</span></span> l)))))))</span><br><span class="line"> </span><br><span class="line">(<span class="name">println</span> ((<span class="name">insertR-f</span> =) 'cake 'cheese '(<span class="name"><span class="builtin-name">new</span></span> york cheese)))</span><br></pre></td></tr></table></figure>
<p>你有没有发现上面的 <code>insertR</code> 和 <code>insertL</code> 的中间代码都非常相似。下面我们将用 <code>insert-g</code> 函数替代上面重复代码。用 <code>seqL</code> 和 <code>seqR</code> 分别代替不重复部分的代码。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> seqL</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [new old l]</span><br><span class="line">    (<span class="name"><span class="builtin-name">cons</span></span> new (<span class="name"><span class="builtin-name">cons</span></span> old l))))</span><br><span class="line"> </span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> seqR</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [new old l]</span><br><span class="line">    (<span class="name"><span class="builtin-name">cons</span></span> old (<span class="name"><span class="builtin-name">cons</span></span> new l))))</span><br><span class="line"> </span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> insert-g</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [seqarg]</span><br><span class="line">    (<span class="name"><span class="builtin-name">fn</span></span> [new old l]</span><br><span class="line">      (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">        (<span class="name">null?</span> l) '()</span><br><span class="line">        (<span class="name"><span class="builtin-name">=</span></span> (<span class="name"><span class="builtin-name">first</span></span> l) old) (<span class="name">seqarg</span> new old (<span class="name"><span class="builtin-name">rest</span></span> l))</span><br><span class="line">        <span class="literal">true</span> (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name"><span class="builtin-name">first</span></span> l) ((<span class="name">insert-g</span> seqarg) new old (<span class="name"><span class="builtin-name">rest</span></span> l)))))))</span><br><span class="line"> </span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> insertL (<span class="name">insert-g</span> seqL))</span><br><span class="line">(<span class="name">println</span> (<span class="name">insertL</span> 'creamy 'latte '(<span class="name">a</span> hot cup of latte)))</span><br><span class="line"><span class="comment">;//=&gt;(a hot cup of creamy latte)</span></span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> insertR (<span class="name">insert-g</span> seqR))</span><br><span class="line">(<span class="name">println</span> (<span class="name">insertR</span> 'cake 'cheese '(<span class="name"><span class="builtin-name">new</span></span> york cheese)))</span><br><span class="line"><span class="comment">;//=&gt;(new york cheese cake)</span></span><br></pre></td></tr></table></figure>
<p>利用上面的提取公因式的代码 重构 <code>insertL</code> </p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> insertL</span><br><span class="line">  (<span class="name">insert-g</span></span><br><span class="line">    (<span class="name"><span class="builtin-name">fn</span></span> [new old l]</span><br><span class="line">      (<span class="name"><span class="builtin-name">cons</span></span> new (<span class="name"><span class="builtin-name">cons</span></span> old l)))))</span><br><span class="line">(<span class="name">println</span> (<span class="name">insertL</span> 'creamy 'latte '(<span class="name">a</span> hot cup of latte)))</span><br><span class="line"><span class="comment">;//=&gt;(a hot cup of creamy latte)</span></span><br></pre></td></tr></table></figure>
<p>现在回看 <a href="/clojure/2015/02/12/the-little-schemer-in-clojure-chapter-3.html">Chapter 3</a>的 <code>subst</code></p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> subst</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [new old l]</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">      (<span class="name">null?</span> l) '()</span><br><span class="line">      (<span class="name"><span class="builtin-name">=</span></span> (<span class="name"><span class="builtin-name">first</span></span> l) old) (<span class="name"><span class="builtin-name">cons</span></span> new (<span class="name"><span class="builtin-name">rest</span></span> l))</span><br><span class="line">      <span class="literal">true</span> (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name"><span class="builtin-name">first</span></span> l) (<span class="name">subst</span> new old (<span class="name"><span class="builtin-name">rest</span></span> l))))))</span><br><span class="line"> </span><br><span class="line">(<span class="name">println</span> (<span class="name">subst</span> 'espresso 'latte '(<span class="name">a</span> hot cup of latte)))</span><br><span class="line"><span class="comment">;//=&gt;(a hot cup of espresso)</span></span><br></pre></td></tr></table></figure>
<p>有没有发现subst和 <code>insertL</code>, <code>insertR</code> 很类似，它仅仅是没有把old cons进去。所以我们同样可以用 <code>insert-g</code> 重构。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> seqS</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [new old l]</span><br><span class="line">    (<span class="name"><span class="builtin-name">cons</span></span> new l)))</span><br><span class="line"> </span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> subst (<span class="name">insert-g</span> seqS))</span><br><span class="line"> </span><br><span class="line">(<span class="name">println</span> (<span class="name">subst</span> 'espresso 'latte '(<span class="name">a</span> hot cup of latte)))</span><br><span class="line"><span class="comment">;//&gt;(a hot cup of espresso)</span></span><br></pre></td></tr></table></figure>
<p>下面重构 <code>rember</code></p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> seqrem</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [new old l]</span><br><span class="line">    l))</span><br><span class="line"> </span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> rember</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [a l]</span><br><span class="line">    ((<span class="name">insert-g</span> seqrem) <span class="literal">nil</span> a l)))</span><br><span class="line"> </span><br><span class="line">(<span class="name">println</span> (<span class="name">rember</span> 'hot '(<span class="name">a</span> hot cup of espresso)))</span><br><span class="line"><span class="comment">;//=&gt;(a cup of espresso)</span></span><br></pre></td></tr></table></figure>
<p>第十要义：</p>
<p><strong>“Abstract functions with common structures into a single function”</strong></p>
<p>就是提取公因式，并提取出来作为独立函数。</p>
<p>现在回头看 <a href="/clojure/2015/02/22/the-little-schemer-in-clojure-chapter-7.html">Chapter 7</a> 的 <code>value</code></p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> number_?</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [a]</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">      (<span class="name">null?</span> a) <span class="literal">false</span></span><br><span class="line">      (<span class="name"><span class="builtin-name">number?</span></span> a) <span class="literal">true</span></span><br><span class="line">      <span class="literal">true</span> <span class="literal">false</span>)))</span><br><span class="line"> </span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> first-sub-exp</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [aexp]</span><br><span class="line">    (<span class="name"><span class="builtin-name">first</span></span> (<span class="name"><span class="builtin-name">rest</span></span> aexp))))</span><br><span class="line"> </span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> second-sub-exp</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [aexp]</span><br><span class="line">    (<span class="name"><span class="builtin-name">first</span></span> (<span class="name"><span class="builtin-name">rest</span></span> (<span class="name"><span class="builtin-name">rest</span></span> aexp)))))</span><br><span class="line"> </span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> operator</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [aexp]</span><br><span class="line">    (<span class="name"><span class="builtin-name">first</span></span> aexp)))</span><br><span class="line"> </span><br><span class="line">(<span class="name"><span class="builtin-name">use</span></span> 'clojure.math.numeric-tower)</span><br><span class="line"> </span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> value</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [aexp]</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">      (<span class="name">number_?</span> aexp) aexp</span><br><span class="line">      (<span class="name"><span class="builtin-name">=</span></span> (<span class="name">operator</span> aexp) '+) (<span class="name"><span class="builtin-name">+</span></span> (<span class="name">value</span> (<span class="name">first-sub-exp</span> aexp)) (<span class="name">value</span>  (<span class="name">second-sub-exp</span> aexp)))</span><br><span class="line">      (<span class="name"><span class="builtin-name">=</span></span> (<span class="name">operator</span> aexp) '*) (<span class="name"><span class="builtin-name">*</span></span> (<span class="name">value</span> (<span class="name">first-sub-exp</span> aexp)) (<span class="name">value</span> (<span class="name">second-sub-exp</span> aexp)))</span><br><span class="line">      (<span class="name"><span class="builtin-name">=</span></span> (<span class="name">operator</span> aexp) 'exp) (<span class="name">expt</span> (<span class="name">value</span> (<span class="name">first-sub-exp</span> aexp)) (<span class="name">value</span> (<span class="name">second-sub-exp</span> aexp))))))</span><br><span class="line"> </span><br><span class="line">(<span class="name">println</span> (<span class="name">value</span> '(<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> <span class="number">1</span>)))</span><br><span class="line"><span class="comment">;//=&gt;2</span></span><br></pre></td></tr></table></figure>
<p>现在通过使用一个 可以将一个符号字符串 返回成相应函数的函数：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> atom-to-function</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [x]</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">      (<span class="name"><span class="builtin-name">=</span></span> x '+ ) +</span><br><span class="line">      (<span class="name"><span class="builtin-name">=</span></span> x '* ) *</span><br><span class="line">      (<span class="name"><span class="builtin-name">=</span></span> x 'exp ) expt )))</span><br><span class="line"> </span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> value</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [aexp]</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">      (<span class="name">number_?</span> aexp) aexp</span><br><span class="line">      <span class="literal">true</span> ((<span class="name">atom-to-function</span> (<span class="name">operator</span> aexp))</span><br><span class="line">             (<span class="name">value</span> (<span class="name">first-sub-exp</span> aexp))</span><br><span class="line">             (<span class="name">value</span> (<span class="name">second-sub-exp</span> aexp))))))</span><br><span class="line"> </span><br><span class="line">(<span class="name">println</span> (<span class="name">value</span> '(<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> <span class="number">1</span>)))</span><br><span class="line"><span class="comment">;//=&gt; 2</span></span><br></pre></td></tr></table></figure>
<p>现在是不是变短一些了。</p>
<p>现在回到 <a href="/clojure/2015/03/04/the-little-schemer-in-clojure-chapter-8.html">Chapter 8</a> 看 <code>subset?</code> 和 <code>intersect?</code></p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> member?</span><br><span class="line">  <span class="string">" a is a member of lat?"</span></span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [a lat]</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">      (<span class="name">null?</span> lat) <span class="literal">false</span></span><br><span class="line">      <span class="symbol">:else</span> (<span class="name"><span class="builtin-name">or</span></span></span><br><span class="line">        (<span class="name"><span class="builtin-name">=</span></span> (<span class="name"><span class="builtin-name">first</span></span> lat) a)</span><br><span class="line">        (<span class="name">member?</span> a (<span class="name"><span class="builtin-name">rest</span></span> lat)))) ))</span><br><span class="line"> </span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> subset?</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [set1 set2]</span><br><span class="line">  <span class="string">"set1 is subset of set2 ?"</span></span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">      (<span class="name">null?</span> set1) <span class="literal">true</span></span><br><span class="line">      <span class="symbol">:else</span> (<span class="name"><span class="builtin-name">and</span></span></span><br><span class="line">             (<span class="name">member?</span> (<span class="name"><span class="builtin-name">first</span></span> set1) set2)</span><br><span class="line">             (<span class="name">subset?</span> (<span class="name"><span class="builtin-name">rest</span></span> set1) set2)))))</span><br><span class="line">(<span class="name">println</span> (<span class="name">subset?</span> '(<span class="name">a</span> b c) '(<span class="name">b</span> c d)))</span><br><span class="line"><span class="comment">;//=&gt;false</span></span><br><span class="line">(<span class="name">println</span> (<span class="name">subset?</span> '(<span class="name">b</span> c) '(<span class="name">b</span> c d)))</span><br><span class="line"><span class="comment">;//=&gt;true</span></span><br><span class="line"> </span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> intersect?</span><br><span class="line">  <span class="string">"if set1 has at least one atom in set2"</span></span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [set1 set2]</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">      (<span class="name">null?</span> set1) <span class="literal">false</span></span><br><span class="line">      <span class="symbol">:else</span> (<span class="name"><span class="builtin-name">or</span></span></span><br><span class="line">             (<span class="name">member?</span> (<span class="name"><span class="builtin-name">first</span></span> set1) set2)</span><br><span class="line">             (<span class="name">intersect?</span> (<span class="name"><span class="builtin-name">rest</span></span> set1) set2)))))</span><br><span class="line"> </span><br><span class="line">(<span class="name">println</span> (<span class="name">intersect?</span> '(<span class="name">a</span> b c) '(<span class="name">b</span> c d)))</span><br><span class="line"><span class="comment">;//=&gt;true</span></span><br></pre></td></tr></table></figure>
<p>我们发现上面的函数仅仅在 else里面的 or/and 以及递归终止时返回 true/false 不同，抽象之</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> set-f?</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [logical? const]</span><br><span class="line">    (<span class="name"><span class="builtin-name">fn</span></span> [set1 set2]</span><br><span class="line">      (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">        (<span class="name">null?</span> set1) const</span><br><span class="line">        <span class="symbol">:else</span> (<span class="name">logical?</span></span><br><span class="line">               (<span class="name">member?</span> (<span class="name"><span class="builtin-name">first</span></span> set1) set2)</span><br><span class="line">               ((<span class="name">set-f?</span> logical? const) (<span class="name"><span class="builtin-name">rest</span></span> set1) set2))))))</span><br><span class="line"> </span><br><span class="line"><span class="comment">;(def subset? (set-f? and true))</span></span><br><span class="line"><span class="comment">;(def intersect? (set-f? or nil))</span></span><br><span class="line"><span class="comment">; note - doesn't work yet</span></span><br></pre></td></tr></table></figure>
<p>但上面无法工作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CompilerException java.lang.RuntimeException: Can&apos;t take value of a macro: #&apos;clojure.core/and, compiling:(/Users/caorong/Documents/workspace_clojure/little-schemer/src/little_schemer/chapter8.clj:161:14)</span><br></pre></td></tr></table></figure>
<p>于是我们不得不重新定义 <code>and</code> 或者自己要用到的函数</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> and-prime</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [x y]</span><br><span class="line">    (<span class="name"><span class="builtin-name">and</span></span> x y)))</span><br><span class="line"> </span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> or-prime</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [x y]</span><br><span class="line">    (<span class="name"><span class="builtin-name">or</span></span> x y)))</span><br><span class="line"><span class="comment">; still doesn't work</span></span><br><span class="line"> </span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> or-prime</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [x set1 set2]</span><br><span class="line">    (<span class="name"><span class="builtin-name">or</span></span> x (<span class="name">intersect?</span> (<span class="name"><span class="builtin-name">rest</span></span> set1) set2))))</span><br><span class="line"> </span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> and-prime</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [x set1 set2]</span><br><span class="line">    (<span class="name"><span class="builtin-name">and</span></span> x (<span class="name">subset?</span> (<span class="name"><span class="builtin-name">rest</span></span> set1) set2))))</span><br><span class="line"> </span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> set-f?</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [logical? const]</span><br><span class="line">    (<span class="name"><span class="builtin-name">fn</span></span> [set1 set2]</span><br><span class="line">      (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">        (<span class="name">null?</span> set1) const</span><br><span class="line">        <span class="literal">true</span> (<span class="name">logical?</span></span><br><span class="line">               (<span class="name">member?</span> (<span class="name"><span class="builtin-name">first</span></span> set1) set2)</span><br><span class="line">               set1 set2)))))</span><br><span class="line"> </span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> intersect? (<span class="name">set-f?</span> or-prime <span class="literal">false</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> subset? (<span class="name">set-f?</span> and-prime <span class="literal">true</span>))</span><br><span class="line"> </span><br><span class="line">(<span class="name">println</span> (<span class="name">intersect?</span>  '(<span class="name">toasted</span> banana bread) '(<span class="name">breakfast</span> toasted banana bread with butter for breakfast)))</span><br><span class="line"><span class="comment">;//=&gt;true</span></span><br><span class="line">(<span class="name">println</span> (<span class="name">subset?</span> '(<span class="name">banana</span> butter) '(<span class="name">breakfast</span> toasted banana bread with butter for breakfast)))</span><br><span class="line"><span class="comment">;//=&gt;true</span></span><br></pre></td></tr></table></figure>
<p>这里需要小心 <code>intersect?</code> 的递归的定义与使用， 这里我们用了个我们事先未定义的函数，然后用这个俄函数定义 <code>intersect?</code> 有点绕。</p>
<p>我们将 <code>and-prime</code> 和 <code>or-prime</code> 作为 <code>set-f</code> 的参数。</p>
<p>后面我们将继续 Y Combinator 的推导，从 <a href="/clojure/2015/02/21/the-little-schemer-in-clojure-chapter-5.html">Chapter5</a>的 <code>multirember</code> 开始 ，从去掉 <code>cond</code> 开始。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> multirember</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [a lat]</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">      (<span class="name">null?</span> lat) '()</span><br><span class="line">      (<span class="name"><span class="builtin-name">=</span></span> (<span class="name"><span class="builtin-name">first</span></span> lat) a) (<span class="name">multirember</span> a (<span class="name"><span class="builtin-name">rest</span></span> lat))</span><br><span class="line">      <span class="literal">true</span> (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name"><span class="builtin-name">first</span></span> lat) (<span class="name">multirember</span> a (<span class="name"><span class="builtin-name">rest</span></span> lat))))))</span><br><span class="line"> </span><br><span class="line">(<span class="name">println</span> (<span class="name">multirember</span> 'breakfast '(<span class="name">breakfast</span> toasted banana bread with butter for breakfast)))</span><br><span class="line"><span class="comment">;//=&gt;(toasted banana bread with butter for)</span></span><br></pre></td></tr></table></figure>
<p>curry 化此函数，变成单一功能函数 （略蛋疼）</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> mrember-curry</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [l]</span><br><span class="line">    (<span class="name">multirember</span> 'curry l)))</span><br><span class="line"> </span><br><span class="line">(<span class="name">println</span> (<span class="name">mrember-curry</span> '(<span class="name">curry</span> chicken with curry rice)))</span><br><span class="line"><span class="comment">;//=&gt;(chicken with rice)</span></span><br></pre></td></tr></table></figure>
<p>非 curry 化的重写</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> mrember-curry</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [l]</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">      (<span class="name">null?</span> l) '()</span><br><span class="line">      (<span class="name"><span class="builtin-name">=</span></span> (<span class="name"><span class="builtin-name">first</span></span> l) 'curry) (<span class="name">mrember-curry</span> (<span class="name"><span class="builtin-name">rest</span></span> l))</span><br><span class="line">      <span class="literal">true</span> (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name"><span class="builtin-name">first</span></span> l) (<span class="name">mrember-curry</span> (<span class="name"><span class="builtin-name">rest</span></span> l))))))</span><br><span class="line"> </span><br><span class="line">(<span class="name">println</span> (<span class="name">mrember-curry</span> '(<span class="name">curry</span> chicken with curry rice)))</span><br><span class="line"><span class="comment">;//=&gt;(chicken with rice)</span></span><br></pre></td></tr></table></figure>
<p>让我们对上面的函数继续 curry 化</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> curry-maker</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [future]</span><br><span class="line">    (<span class="name"><span class="builtin-name">fn</span></span> [l]</span><br><span class="line">      (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">        (<span class="name">null?</span> l) '()</span><br><span class="line">        (<span class="name"><span class="builtin-name">=</span></span> (<span class="name"><span class="builtin-name">first</span></span> l) 'curry) ((<span class="name">curry-maker</span> future) (<span class="name"><span class="builtin-name">rest</span></span> l))</span><br><span class="line">        <span class="literal">true</span> (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name"><span class="builtin-name">first</span></span> l) ((<span class="name">curry-maker</span> future) (<span class="name"><span class="builtin-name">rest</span></span> l)))))))</span><br><span class="line"> </span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> mrember-curry (<span class="name">curry-maker</span> <span class="number">0</span>))</span><br><span class="line"><span class="comment">;//=&gt;(chicken with rice)</span></span><br></pre></td></tr></table></figure>
<p>上面这么干虽然没意义，甚至于这个future没有任何意义，目前只是让他弄的像 <code>insert-g</code> 替代 <code>insertL</code> 一样。 -</p>
<p>下面是使用方法，用函数构造函数，然后用之。。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> mrember-curry</span><br><span class="line">  (<span class="name">curry-maker</span> curry-maker))</span><br><span class="line"> </span><br><span class="line">(<span class="name">println</span> (<span class="name">mrember-curry</span> '(<span class="name">curry</span> chicken with curry rice)))</span><br><span class="line"><span class="comment">;//=&gt;(chicken with rice)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> function-maker</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [future]</span><br><span class="line">    (<span class="name"><span class="builtin-name">fn</span></span> [l]</span><br><span class="line">      (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">        (<span class="name">null?</span> l) '()</span><br><span class="line">        (<span class="name"><span class="builtin-name">=</span></span> (<span class="name"><span class="builtin-name">first</span></span> l) 'curry) ((<span class="name"><span class="builtin-name">future</span></span> future) (<span class="name"><span class="builtin-name">rest</span></span> l))</span><br><span class="line">        <span class="literal">true</span> (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name"><span class="builtin-name">first</span></span> l) ((<span class="name"><span class="builtin-name">future</span></span> future) (<span class="name"><span class="builtin-name">rest</span></span> l)))))))</span><br><span class="line"> </span><br><span class="line"><span class="comment">;for yielding mrember-curry when applied to a fcuntion</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">;</span></span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> mrember-curry</span><br><span class="line">  (<span class="name">function-maker</span> function-maker))</span><br><span class="line">(<span class="name">println</span> (<span class="name">mrember-curry</span> '(<span class="name">curry</span> chicken with curry rice)))</span><br><span class="line"><span class="comment">;//=&gt;(chicken with rice)</span></span><br></pre></td></tr></table></figure>
<p>现在，我们把 <code>future</code> 函数换掉，换成自己的匿名函数 </p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> function-maker</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [future]</span><br><span class="line">    (<span class="name"><span class="builtin-name">fn</span></span> [l]</span><br><span class="line">      (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">        (<span class="name">null?</span> l) '()</span><br><span class="line">        (<span class="name"><span class="builtin-name">=</span></span> (<span class="name"><span class="builtin-name">first</span></span> l) 'curry) ((<span class="name"><span class="builtin-name">fn</span></span> [arg] ((<span class="name"><span class="builtin-name">future</span></span> future) arg)) (<span class="name"><span class="builtin-name">rest</span></span> l))</span><br><span class="line">        <span class="literal">true</span> (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name"><span class="builtin-name">first</span></span> l) ((<span class="name"><span class="builtin-name">fn</span></span> [arg] ((<span class="name"><span class="builtin-name">future</span></span> future) arg)) (<span class="name"><span class="builtin-name">rest</span></span> l)))))))</span><br><span class="line"> </span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> mrember-curry</span><br><span class="line">  (<span class="name">function-maker</span> function-maker))</span><br><span class="line">(<span class="name">println</span> (<span class="name">mrember-curry</span> '(<span class="name">curry</span> chicken with curry rice)))</span><br><span class="line"><span class="comment">;//=&gt;(chicken with rice)</span></span><br></pre></td></tr></table></figure>
<p>当然可以用。</p>
<p>下面，我们将已经2此 curry 化的 function-maker 再次 curry 化…</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> function-maker</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [future]</span><br><span class="line">    ((<span class="name"><span class="builtin-name">fn</span></span> [recfun]</span><br><span class="line">      (<span class="name"><span class="builtin-name">fn</span></span> [l]</span><br><span class="line">        (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">          (<span class="name">null?</span> l) '()</span><br><span class="line">          (<span class="name"><span class="builtin-name">=</span></span> (<span class="name"><span class="builtin-name">first</span></span> l) 'curry) (<span class="name">recfun</span> (<span class="name"><span class="builtin-name">rest</span></span> l))</span><br><span class="line">        <span class="literal">true</span> (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name"><span class="builtin-name">first</span></span> l) ((<span class="name"><span class="builtin-name">future</span></span> future))))))</span><br><span class="line">    (<span class="name"><span class="builtin-name">fn</span></span> [arg] ((<span class="name"><span class="builtin-name">future</span></span> future) arg)))))</span><br><span class="line"><span class="comment">;abstraction above to remove l</span></span><br><span class="line"><span class="comment">; just take my word on this for now</span></span><br></pre></td></tr></table></figure>
<p>将上面的函数，拆分成 2 部分</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> M</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [recfun]</span><br><span class="line">    (<span class="name"><span class="builtin-name">fn</span></span> [l]</span><br><span class="line">      (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">        (<span class="name">null?</span> l) '()</span><br><span class="line">        (<span class="name"><span class="builtin-name">=</span></span> (<span class="name"><span class="builtin-name">first</span></span> l) 'curry) (<span class="name">recfun</span> (<span class="name"><span class="builtin-name">rest</span></span> l))</span><br><span class="line">        <span class="literal">true</span> (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name"><span class="builtin-name">first</span></span> l) (<span class="name">recfun</span> (<span class="name"><span class="builtin-name">rest</span></span> l)))))))</span><br><span class="line"> </span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> function-maker</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [future]</span><br><span class="line">    (<span class="name">M</span> (<span class="name"><span class="builtin-name">fn</span></span> [arg]</span><br><span class="line">         ((<span class="name"><span class="builtin-name">future</span></span> future) arg)))))</span><br></pre></td></tr></table></figure>
<p>现在可以不需要显示的 <code>function-maker</code> 引用来重构 <code>mrember-curry</code></p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;Now we'll change this</span></span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> mrember-curry</span><br><span class="line">  (<span class="name">function-maker</span> function-maker))</span><br><span class="line"><span class="comment">;to this</span></span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> mrember-curry</span><br><span class="line">  ((<span class="name"><span class="builtin-name">fn</span></span> [future]</span><br><span class="line">     (<span class="name">M</span> (<span class="name"><span class="builtin-name">fn</span></span> [arg]</span><br><span class="line">          ((<span class="name"><span class="builtin-name">future</span></span> future) arg))))</span><br><span class="line">    (<span class="name"><span class="builtin-name">fn</span></span> [future]</span><br><span class="line">      (<span class="name">M</span> (<span class="name"><span class="builtin-name">fn</span></span> [arg]</span><br><span class="line">           ((<span class="name"><span class="builtin-name">future</span></span> future) arg))))))</span><br></pre></td></tr></table></figure>
<p>将上面干的事情提取成 Y ，它将接受一个 M (函数)作为参数</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> Y</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [M]</span><br><span class="line">    ((<span class="name"><span class="builtin-name">fn</span></span> [future]</span><br><span class="line">       (<span class="name">M</span> (<span class="name"><span class="builtin-name">fn</span></span> [arg]</span><br><span class="line">            ((<span class="name"><span class="builtin-name">future</span></span> future) arg))))</span><br><span class="line">      (<span class="name"><span class="builtin-name">fn</span></span> [future]</span><br><span class="line">        (<span class="name">M</span> (<span class="name"><span class="builtin-name">fn</span></span> [arg]</span><br><span class="line">             ((<span class="name"><span class="builtin-name">future</span></span> future) arg)))))))</span><br><span class="line"> </span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> mrember-curry (<span class="name">Y</span> M))</span><br><span class="line"> </span><br><span class="line">(<span class="name">println</span> (<span class="name">mrember-curry</span> '(<span class="name">curry</span> chicken with curry rice)))</span><br><span class="line"><span class="comment">;//=&gt;(chicken with rice)</span></span><br></pre></td></tr></table></figure>
<p>下面我们将把 Y-combinator 用在求length</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;using add1 from chapter 7 not chapter 4</span></span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> add1</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [n]</span><br><span class="line">    (<span class="name"><span class="builtin-name">cons</span></span> '() n)))</span><br><span class="line"> </span><br><span class="line"><span class="comment">; now we'll look at using the y-combinator to look at the length of a list</span></span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> L</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [recfun]</span><br><span class="line">    (<span class="name"><span class="builtin-name">fn</span></span> [l]</span><br><span class="line">      (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">        (<span class="name">null?</span> l) '()</span><br><span class="line">        <span class="literal">true</span> (<span class="name">add1</span> (<span class="name">recfun</span> (<span class="name"><span class="builtin-name">rest</span></span> l)))))))</span><br><span class="line"> </span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> length (<span class="name">Y</span> L))</span><br><span class="line"> </span><br><span class="line">(<span class="name">println</span> (<span class="name">length</span> '(<span class="name">curry</span> chicken with curry rice)))</span><br><span class="line"><span class="comment">;//=&gt;(() () () () ()) ie 5</span></span><br></pre></td></tr></table></figure>
<p>下面我们重定义了add1， 并且把 L 作为匿名函数定义</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> add1</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [n]</span><br><span class="line">    (<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> n)))</span><br><span class="line"> </span><br><span class="line"><span class="comment">;just for the sake of it - we'll rewrite length without the L function</span></span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> length</span><br><span class="line">  (<span class="name">Y</span></span><br><span class="line">    (<span class="name"><span class="builtin-name">fn</span></span> [recfun]</span><br><span class="line">      (<span class="name"><span class="builtin-name">fn</span></span> [l]</span><br><span class="line">        (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">          (<span class="name">null?</span> l) <span class="number">0</span></span><br><span class="line">          <span class="literal">true</span> (<span class="name">add1</span> (<span class="name">recfun</span> (<span class="name"><span class="builtin-name">rest</span></span> l))))))))</span><br><span class="line"> </span><br><span class="line">(<span class="name">println</span> (<span class="name">length</span> '(<span class="name">curry</span> chicken with curry rice)))</span><br><span class="line"><span class="comment">;//=&gt;5</span></span><br></pre></td></tr></table></figure>
<p>不用 Y 和 L 重写length</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> length</span><br><span class="line">  ((<span class="name"><span class="builtin-name">fn</span></span> [M]</span><br><span class="line">     ((<span class="name"><span class="builtin-name">fn</span></span> [future]</span><br><span class="line">        (<span class="name">M</span> (<span class="name"><span class="builtin-name">fn</span></span> [arg]</span><br><span class="line">             ((<span class="name"><span class="builtin-name">future</span></span> future) arg))))</span><br><span class="line">     (<span class="name"><span class="builtin-name">fn</span></span> [future]</span><br><span class="line">       (<span class="name">M</span> (<span class="name"><span class="builtin-name">fn</span></span> [arg]</span><br><span class="line">            ((<span class="name"><span class="builtin-name">future</span></span> future) arg))))))</span><br><span class="line">    (<span class="name"><span class="builtin-name">fn</span></span> [recfun]</span><br><span class="line">      (<span class="name"><span class="builtin-name">fn</span></span> [l]</span><br><span class="line">        (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">          (<span class="name">null?</span> l) <span class="number">0</span></span><br><span class="line">          <span class="literal">true</span> (<span class="name">add1</span> (<span class="name">recfun</span> (<span class="name"><span class="builtin-name">rest</span></span> l))))))))</span><br><span class="line"> </span><br><span class="line">(<span class="name">println</span> (<span class="name">length</span> '(<span class="name">curry</span> chicken with curry rice)))</span><br><span class="line"><span class="comment">;//=&gt;5</span></span><br></pre></td></tr></table></figure>
<p>本章结束，但是我们想更深入下，用 ycombinator 开始定义一个惰性函数</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;building a pair with an S-expression and a thunk leads to a stream</span></span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> first$ first)</span><br><span class="line"> </span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> second$</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [str]</span><br><span class="line">    ((<span class="name"><span class="builtin-name">second</span></span> str))))</span><br><span class="line"> </span><br><span class="line"><span class="comment">; careful re use of first and second here - as yet undefined!</span></span><br><span class="line"> </span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> build</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [a b]</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">      <span class="literal">true</span> (<span class="name"><span class="builtin-name">cons</span></span> a (<span class="name"><span class="builtin-name">cons</span></span> b '())))))</span><br><span class="line"> </span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> str-maker</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [next n]</span><br><span class="line">    (<span class="name">build</span> n (<span class="name"><span class="builtin-name">fn</span></span> [] (<span class="name">str-maker</span> next (<span class="name"><span class="builtin-name">next</span></span> n))))))</span><br><span class="line"> </span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> int_ (<span class="name">str-maker</span> add1 <span class="number">0</span>))</span><br><span class="line"> </span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> even (<span class="name">str-maker</span> (<span class="name"><span class="builtin-name">fn</span></span> [n] (<span class="name"><span class="builtin-name">+</span></span> <span class="number">2</span> n)) <span class="number">0</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment">;sub1 from chapter 4</span></span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> sub1</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [n]</span><br><span class="line">    (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>)))</span><br><span class="line"> </span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> frontier</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [str n]</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">      (<span class="name"><span class="builtin-name">zero?</span></span> n) '()</span><br><span class="line">      <span class="literal">true</span> (<span class="name"><span class="builtin-name">cons</span></span> (<span class="name"><span class="builtin-name">first</span></span>$ str) (<span class="name">frontier</span> (<span class="name"><span class="builtin-name">second</span></span>$ str) (<span class="name">sub1</span> n))))))</span><br><span class="line"> </span><br><span class="line">(<span class="name">frontier</span> int_ <span class="number">10</span>)</span><br><span class="line"><span class="comment">;//=&gt;(0 1 2 3 4 5 6 7 8 9)</span></span><br></pre></td></tr></table></figure>
<p>上面的 second 其实是不停的构造新的的函数（入参一直在变化的函数）</p>
<p>上面我们构造了了一个简单的 惰性数据结构，下面的例子更有趣</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">def</span></span> Q</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [str n]</span><br><span class="line">    (<span class="name"><span class="builtin-name">cond</span></span></span><br><span class="line">      (<span class="name"><span class="builtin-name">zero?</span></span> (<span class="name"><span class="builtin-name">rem</span></span> (<span class="name"><span class="builtin-name">first</span></span>$ str) n)) (<span class="name">Q</span> (<span class="name"><span class="builtin-name">second</span></span>$ str) n)</span><br><span class="line">      <span class="literal">true</span> (<span class="name">build</span> (<span class="name"><span class="builtin-name">first</span></span>$ str) (<span class="name"><span class="builtin-name">fn</span></span> [] (<span class="name">Q</span> (<span class="name"><span class="builtin-name">second</span></span>$ str) n))))))</span><br><span class="line"><span class="comment">; note new function call rem - re new primitve</span></span><br><span class="line"> </span><br><span class="line">(<span class="name"><span class="builtin-name">def</span></span> P</span><br><span class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [str]</span><br><span class="line">    (<span class="name">build</span> (<span class="name"><span class="builtin-name">first</span></span>$ str) (<span class="name"><span class="builtin-name">fn</span></span> [] (<span class="name">P</span> (<span class="name">Q</span> str (<span class="name"><span class="builtin-name">first</span></span>$ str)))))))</span><br><span class="line"> </span><br><span class="line">(<span class="name">frontier</span> (<span class="name">P</span> (<span class="name"><span class="builtin-name">second</span></span>$ (<span class="name"><span class="builtin-name">second</span></span>$ int_))) <span class="number">10</span>)</span><br><span class="line"><span class="comment">;//=&gt;(2 3 5 7 11 13 17 19 23 29)</span></span><br></pre></td></tr></table></figure>

  </section>
</article>

  <div class="sharing grid">
  <section class="profile grid-item grid">
    <img class="avatar" src="https://gravatar.css.network/avatar/f6adb1529491a56dbe31c57d519585f5?s=400&r=g" alt="avatar" />
    <div class="grid-item">
      <p class="title"> lelouchcr's blog </p>
      <p class="subtitle">  </p>
    <div>
  </section>

  <section class="share-btns">
    <!-- <p> share it if you like it~ </p> -->
    <a
  class="twitter-share-button"
  data-size="large"
  data-via="DrakeLeung"
  href="https://twitter.com/intent/tweet?text=翻译自 <a href="http://"
>
  Tweet
</a>

<script>
  window.twttr = (function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0],
    t = window.twttr || {};
  if (d.getElementById(id)) return t;
  js = d.createElement(s);
  js.id = id;
  js.src = "https://platform.twitter.com/widgets.js";
  js.async = true;
  fjs.parentNode.insertBefore(js, fjs);

  t._e = [];
  t.ready = function(f) {
    t._e.push(f);
  };

  return t;
}(document, "script", "twitter-wjs"));
</script>

  </section>
</div>


  
    
<section class="article-comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

<script>
  var disqus_shortname = 'caorong';
  
  var disqus_url = 'http://caorong.github.io/2015/03/14/the-little-schemer-in-clojure-chapter-9/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


  
  

<script>
    setTimeout(function() {
            var hjs = document.createElement('script');
            hjs.setAttribute('src', 'http://lelouchcrgallery.tk/rand?ratio=0.625&range=0.2&source=pixiv&encode=jsc&func=lgallery');
            document.body.appendChild(hjs);
        }, 0);

    function lgallery(option) {
            console.log(option);
            var bgimg = document.createElement('img');
            bgimg.setAttribute('src', option.p_ori);
            bgimg.setAttribute('id', 'bkImg');
            bgimg.setAttribute('onmousedown', 'return false');
            document.body.appendChild(bgimg);
        }

</script>

</main>

</body>
</html>
